<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>^⁠_⁠^</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: #020205; 
            font-family: 'Palatino Linotype', serif;
        }
        canvas { display: block; }

        /* Initial Overlay to bypass Autoplay restrictions */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2, 2, 5, 0.9);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; z-index: 1000; cursor: pointer;
            transition: opacity 1s ease;
        }
        #overlay h1 { color: white; font-style: italic; letter-spacing: 2px; }
        #overlay p { color: rgba(255, 255, 255, 0.5); font-size: 0.9em; }
    </style>
</head>
<body>

<div id="overlay">
    <h1>For You ^⁠_⁠^</h1>
    <p>( Click to enter)</p>
</div>

<audio id="bgMusic" loop>
    <source src="glue-song.mp3" type="audio/mpeg">
</audio>

<canvas id="gardenCanvas"></canvas>

<script>
const canvas = document.getElementById('gardenCanvas');
const ctx = canvas.getContext('2d');
const music = document.getElementById('bgMusic');
const overlay = document.getElementById('overlay');

let gardenStarted = false;

// Handle Start Interaction
overlay.addEventListener('click', () => {
    overlay.style.opacity = '0';
    setTimeout(() => overlay.style.display = 'none', 1000);
    music.play();
    gardenStarted = true;
    startTime = Date.now(); // Reset start time so animations begin on click
});

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    message.fontSize = Math.min(canvas.width / 15, 45);
}

const random = (min, max) => Math.random() * (max - min) + min;

let startTime = Date.now();
let heartTriggered = false;
let flowers = [];
let butterflies = [];
let particles = [];

const message = {
    line1: "HAPPY VALENTINES DAY,",
    line2: "ELLIE! ^_^",
    opacity: 0,
    visible: false,
    fontSize: 0
};

resize();

class Particle {
    constructor(x, y, hue) {
        this.x = x; this.y = y;
        this.vx = random(-0.5, 0.5);
        this.vy = random(-0.2, -1);
        this.size = random(0.5, 2);
        this.life = 1;
        this.decay = random(0.005, 0.015);
        this.hue = hue;
    }
    update() {
        this.x += this.vx + Math.sin(Date.now() * 0.001) * 0.5;
        this.y += this.vy;
        this.life -= this.decay;
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = `hsla(${this.hue}, 100%, 80%, ${this.life})`;
        ctx.shadowBlur = 5;
        ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Butterfly {
    constructor() { this.reset(); }
    reset() {
        this.x = random(0, canvas.width);
        this.y = random(0, canvas.height);
        this.vx = random(-1.5, 1.5);
        this.vy = random(-1, 1);
        this.size = random(2, 4);
        this.wingAngle = 0;
        this.hue = random(180, 280); 
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.wingAngle += 0.2;
        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
    }
    draw() {
        let ws = Math.abs(Math.sin(this.wingAngle)) * (this.size * 1.5);
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.atan2(this.vy, this.vx));
        ctx.fillStyle = `hsl(${this.hue}, 100%, 75%)`;
        ctx.shadowBlur = 10; ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
        ctx.beginPath();
        ctx.ellipse(0, -ws/2, ws, this.size, 0.5, 0, Math.PI * 2);
        ctx.ellipse(0, ws/2, ws, this.size, -0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Flower {
    constructor(isHeartPart = false, targetX = 0, targetY = 0) {
        this.isHeartPart = isHeartPart;
        this.targetX = targetX;
        this.targetY = targetY;
        this.spawn();
    }
    spawn() {
        this.x = this.isHeartPart ? this.targetX : random(50, canvas.width - 50);
        this.maxH = this.isHeartPart ? (canvas.height - this.targetY) : random(150, canvas.height * 0.7);
        this.curH = 0;
        this.segments = Math.floor(random(6, 9));
        this.petalR = 0;
        this.maxPetalR = random(10, 22);
        this.bloomed = false;
        this.hue = this.isHeartPart ? random(340, 360) : random(280, 340);
        this.opacity = 0;
        this.state = 'GROWING';
        this.stayTimer = 0;
        this.maxStay = this.isHeartPart ? 600 : random(400, 800);
        this.swayOffset = random(0, Math.PI * 2);
        this.segmentKinks = Array.from({length: this.segments}, () => random(-2, 2));
    }
    update() {
        this.sway = Math.sin(Date.now() * 0.001 + this.swayOffset) * (this.curH * 0.05);
        if (this.state === 'GROWING') {
            if (this.opacity < 1) this.opacity += 0.02;
            this.curH += 1.2;
            if (this.curH >= this.maxH) this.state = 'BLOOMING';
        } else if (this.state === 'BLOOMING') {
            this.bloomed = true;
            if (this.petalR < this.maxPetalR) this.petalR += 0.4;
            else {
                this.stayTimer++;
                if (Math.random() < 0.05) particles.push(new Particle(this.lastTopX, this.lastTopY, 50));
                if (this.stayTimer > this.maxStay) this.state = 'FADING';
            }
        } else if (this.state === 'FADING') {
            this.opacity -= 0.01;
            if (this.opacity <= 0) {
                if (this.isHeartPart) this.markedForDeletion = true;
                else this.spawn();
            }
        }
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        let prevX = this.x;
        let prevY = canvas.height;
        for (let i = 1; i <= this.segments; i++) {
            const ratio = i / this.segments;
            const currentY = canvas.height - (this.curH * ratio);
            const currentX = this.x + (this.sway * Math.pow(ratio, 1.5)) + this.segmentKinks[i-1];
            const thickness = Math.max(1, 5 * (1 - ratio * 0.7));
            ctx.strokeStyle = '#2d5a27';
            ctx.lineWidth = thickness;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(prevX, prevY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            if (i === 2 && this.curH > 60) this.drawLeaf(currentX, currentY, -0.8 + (this.sway*0.02), thickness);
            if (i === 4 && this.curH > 100) this.drawLeaf(currentX, currentY, 0.6 + (this.sway*0.02), thickness);
            prevX = currentX;
            prevY = currentY;
        }
        this.lastTopX = prevX;
        this.lastTopY = prevY;
        if (this.bloomed) this.drawFlowerHead(prevX, prevY);
        ctx.restore();
    }
    drawLeaf(x, y, angle, stemWidth) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        const leafGrad = ctx.createLinearGradient(0, 0, 20, 0);
        leafGrad.addColorStop(0, '#1e4d1a'); leafGrad.addColorStop(1, '#3a7d34');
        ctx.fillStyle = leafGrad;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.quadraticCurveTo(10, -8, 22, 0);
        ctx.quadraticCurveTo(10, 8, 0, 0); ctx.fill();
        ctx.restore();
    }
    drawFlowerHead(x, y) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
        for (let i = 0; i < 6; i++) {
            const angle = (i * 60 + (this.sway * 2)) * Math.PI / 180;
            ctx.fillStyle = `hsla(${this.hue}, 80%, 65%, ${this.opacity})`;
            ctx.beginPath();
            ctx.ellipse(x + Math.cos(angle)*(this.petalR*0.6), y + Math.sin(angle)*(this.petalR*0.6), this.petalR, this.petalR/1.8, angle, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.fillStyle = "#ffd700";
        ctx.beginPath(); ctx.arc(x, y, this.petalR/3, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
    }
}

function getHeartPoint(t) {
    const r = Math.min(canvas.width, canvas.height) / 55; 
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return { x: x * r, y: -y * r };
}

function spawnHeart() {
    heartTriggered = true;
    const centerX = canvas.width / 2;
    const centerY = canvas.height * 0.55;
    for (let t = 0; t < Math.PI * 2; t += 0.45) {
        const pos = getHeartPoint(t);
        flowers.push(new Flower(true, centerX + pos.x, centerY + pos.y));
    }
}

function drawGrass() {
    for (let i = 0; i < canvas.width; i += 12) {
        const h = 35 + Math.sin(i * 0.1) * 10;
        const sway = Math.sin(Date.now() * 0.002 + i) * 5;
        ctx.strokeStyle = '#081a08';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(i, canvas.height);
        ctx.quadraticCurveTo(i + sway, canvas.height - h/2, i + sway, canvas.height - h);
        ctx.stroke();
    }
}

function drawMessage() {
    if (!message.visible) return;
    ctx.save();
    ctx.font = `italic bold ${message.fontSize}px "Palatino Linotype", serif`;
    ctx.textAlign = "center";
    ctx.shadowBlur = 20;
    ctx.shadowColor = "rgba(255, 105, 180, 0.8)";
    ctx.fillStyle = `rgba(255, 255, 255, ${message.opacity})`;
    const topPadding = canvas.height * 0.15;
    ctx.fillText(message.line1, canvas.width / 2, topPadding);
    ctx.fillText(message.line2, canvas.width / 2, topPadding + (message.fontSize * 1.2));
    ctx.restore();

    const elapsed = (Date.now() - startTime) / 1000;
    if (message.opacity < 1 && elapsed < 15) message.opacity += 0.01;
    if (elapsed > 20 && message.opacity > 0) message.opacity -= 0.01;
}

// Init
for(let i=0; i<10; i++) flowers.push(new Flower());
for(let i=0; i<6; i++) butterflies.push(new Butterfly());

function animate() {
    ctx.fillStyle = 'rgba(2, 2, 8, 0.3)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if (gardenStarted) {
        drawGrass();
        const elapsed = (Date.now() - startTime) / 1000;
        if (elapsed > 5 && !heartTriggered) { spawnHeart(); message.visible = true; }
        if (elapsed > 35) { startTime = Date.now(); heartTriggered = false; message.visible = false; message.opacity = 0; }
        flowers = flowers.filter(f => !f.markedForDeletion);
        flowers.forEach(f => { f.update(); f.draw(); });
        drawMessage(); 
        butterflies.forEach(b => { b.update(); b.draw(); });
        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => { p.update(); p.draw(); });
    }
    
    requestAnimationFrame(animate);
}

window.addEventListener('resize', resize);
animate();
</script>
</body>
</html>
